adam_update(n_updates, 0.1, .001, embed)
plot2d(embed, col = sbm_data$block_id)
n_updates
n_updates <- round(n_nodes * log(n_nodes)  * 500)
sgd_update(n_updates, 1, .1, embed)
sgd_update(n_updates, 0.1, .001, embed)
plot2d(embed, col = sbm_data$block_id)
embed <- makeEmbed(sbm_data$edgeList, 2)
adam_update(n_updates, 1, .1, embed)
adam_update(n_updates, 0.1, .001, embed)
plot2d(embed, col = sbm_data$block_id)
embed <- makeEmbed(sbm_data$edgeList, 2)
n_updates <- round(n_nodes * log(n_nodes)  * 500)
sgd_update(n_updates, 1, .1, embed)
sgd_update(n_updates, 0.1, .001, embed)
plot2d(embed, col = sbm_data$block_id)
library(plotly)
library(nonLinearEmbed)
makeSBM <- function(blocks = 5,
n_perBlock = 10,
pin = 0.9,
pout = 0.02){
block_id <- rep(1:blocks, n_perBlock)
n = blocks * n_perBlock
edgeList = NULL
for(i in 1:n){
i_id = block_id[i]
for(j in 1:i){
j_id = block_id[j]
if(i == j) next
if(i_id == j_id){ prb = pin }
else prb = pout
if(runif(1) < prb){
edgeList = rbind(edgeList, c(i,j))
}
}
}
ans <- list(edgeList = edgeList,
block_id = block_id)
return(ans)
}
sbm_data <- makeSBM(pin = .5, pout = 0.05,
n_perBlock = 20,
blocks = 5)
n_nodes <- max(sbm_data$edgeList)
embed <- makeEmbed(sbm_data$edgeList, 2)
n_updates <- round(n_nodes * log(n_nodes)  * 500)
sgd_update(n_updates, 1, .1, embed)
sgd_update(n_updates, 0.1, .001, embed)
plot2d(embed, col = sbm_data$block_id)
embed <- makeEmbed(sbm_data$edgeList, 2)
adam_update(n_updates, 1, .1, embed)
adam_update(n_updates, 0.1, .001, embed)
plot2d(embed, col = sbm_data$block_id)
library(plotly)
library(nonLinearEmbed)
makeSBM <- function(blocks = 5,
n_perBlock = 10,
pin = 0.9,
pout = 0.02){
block_id <- rep(1:blocks, n_perBlock)
n = blocks * n_perBlock
edgeList = NULL
for(i in 1:n){
i_id = block_id[i]
for(j in 1:i){
j_id = block_id[j]
if(i == j) next
if(i_id == j_id){ prb = pin }
else prb = pout
if(runif(1) < prb){
edgeList = rbind(edgeList, c(i,j))
}
}
}
ans <- list(edgeList = edgeList,
block_id = block_id)
return(ans)
}
sbm_data <- makeSBM(pin = .5, pout = 0.05,
n_perBlock = 20,
blocks = 5)
n_nodes <- max(sbm_data$edgeList)
embed <- makeEmbed(sbm_data$edgeList, 2)
n_updates <- round(n_nodes * log(n_nodes)  * 500)
sgd_update(n_updates, 1, .1, embed)
sgd_update(n_updates, 0.1, .001, embed)
plot2d(embed, col = sbm_data$block_id)
embed <- makeEmbed(sbm_data$edgeList, 2)
adam_update(n_updates, 1, .1, embed)
adam_update(n_updates, 0.1, .001, embed)
plot2d(embed, col = sbm_data$block_id)
adam_update(n_updates, 0.1, .001, embed)
plot2d(embed, col = sbm_data$block_id)
adam_update(n_updates, 0.1, .001, embed)
plot2d(embed, col = sbm_data$block_id)
adam_update(n_updates, 0.1, .001, embed)
plot2d(embed, col = sbm_data$block_id)
adam_update(n_updates, 0.1, .001, embed)
plot2d(embed, col = sbm_data$block_id)
install.packages("nimble")
T_max <- 4
d<- 3
N_t_T = c(
1,2,3,4
)
## STATE SPACE MODEL STUFF
data <- list(
N_t_T = N_t_T
)
constants <- list(
t = T_max,
d = d
)
inits <- list(
alpha = matrix(rep(1,3),nrow=3,ncol=1)
)
## define the model
stateSpaceCode <- nimbleCode({
p_d[] ~ ddirch(alpha)
q_t <- p_d[1]
x[1] ~ dnorm( 0, sd =1)
lambda[1] ~ dnorm( x[1], sd = 10)
N_t_inf[1] ~ dpois(exp(lambda[1]))
N_t_T[1] ~ dbinom(prob=q_t,size=N_t_inf[1])
for (i in 2:t) {
x[i] ~ dnorm(x[i - 1], sd = 1)
y[i] ~ dnorm(x[i], sd = 1)
N_t_inf[i] ~ dpois(exp(lambda[1]))
N_t_T[i] ~ dbinom(prob=q_t,size=N_t_inf[i])
}
})
## build the model
stateSpaceModel <- nimbleModel(stateSpaceCode,
data = data,
constants = constants,
inits = inits,
dimensions=list(p_d = d),
check = FALSE)
bootstrapFilter <- buildBootstrapFilter(stateSpaceModel, nodes = 'x')
compiledList <- compileNimble(stateSpaceModel, bootstrapFilter)
compiledList$bootstrapFilter$run(10000)
library(nimble)
T_max <- 4
d<- 3
N_t_T = c(
1,2,3,4
)
## STATE SPACE MODEL STUFF
data <- list(
N_t_T = N_t_T
)
constants <- list(
t = T_max,
d = d
)
inits <- list(
alpha = matrix(rep(1,3),nrow=3,ncol=1)
)
## define the model
stateSpaceCode <- nimbleCode({
p_d[] ~ ddirch(alpha)
q_t <- p_d[1]
x[1] ~ dnorm( 0, sd =1)
lambda[1] ~ dnorm( x[1], sd = 10)
N_t_inf[1] ~ dpois(exp(lambda[1]))
N_t_T[1] ~ dbinom(prob=q_t,size=N_t_inf[1])
for (i in 2:t) {
x[i] ~ dnorm(x[i - 1], sd = 1)
y[i] ~ dnorm(x[i], sd = 1)
N_t_inf[i] ~ dpois(exp(lambda[1]))
N_t_T[i] ~ dbinom(prob=q_t,size=N_t_inf[i])
}
})
## build the model
stateSpaceModel <- nimbleModel(stateSpaceCode,
data = data,
constants = constants,
inits = inits,
dimensions=list(p_d = d),
check = FALSE)
bootstrapFilter <- buildBootstrapFilter(stateSpaceModel, nodes = 'x')
compiledList <- compileNimble(stateSpaceModel, bootstrapFilter)
compiledList$bootstrapFilter$run(10000)
library(nimble)
T_max <- 4
d<- 3
N_t_T = c(
1,2,3,4
)
## STATE SPACE MODEL STUFF
data <- list(
N_t_T = N_t_T
)
constants <- list(
t = T_max,
d = d
)
inits <- list(
alpha = matrix(rep(1,3),nrow=3,ncol=1)
)
## define the model
stateSpaceCode <- nimbleCode({
p_d[1:3] ~ ddirch(alpha)
q_t <- p_d[1]
x[1] ~ dnorm( 0, sd =1)
lambda[1] ~ dnorm( x[1], sd = 10)
N_t_inf[1] ~ dpois(exp(lambda[1]))
N_t_T[1] ~ dbinom(prob=q_t,size=N_t_inf[1])
for (i in 2:t) {
x[i] ~ dnorm(x[i - 1], sd = 1)
y[i] ~ dnorm(x[i], sd = 1)
N_t_inf[i] ~ dpois(exp(lambda[1]))
N_t_T[i] ~ dbinom(prob=q_t,size=N_t_inf[i])
}
})
## build the model
stateSpaceModel <- nimbleModel(stateSpaceCode,
data = data,
constants = constants,
inits = inits,
dimensions=list(p_d = d),
check = FALSE)
bootstrapFilter <- buildBootstrapFilter(stateSpaceModel, nodes = 'x')
compiledList <- compileNimble(stateSpaceModel, bootstrapFilter)
compiledList$bootstrapFilter$run(10000)
library(nimble)
T_max <- 4
d<- 3
N_t_T = c(
1,2,3,4
)
## STATE SPACE MODEL STUFF
data <- list(
N_t_T = N_t_T
)
constants <- list(
t = T_max,
d = d
)
inits <- list(
alpha = rep(1,3)
)
## define the model
stateSpaceCode <- nimbleCode({
p_d[1:3] ~ ddirch(alpha)
q_t <- p_d[1]
x[1] ~ dnorm( 0, sd =1)
lambda[1] ~ dnorm( x[1], sd = 10)
N_t_inf[1] ~ dpois(exp(lambda[1]))
N_t_T[1] ~ dbinom(prob=q_t,size=N_t_inf[1])
for (i in 2:t) {
x[i] ~ dnorm(x[i - 1], sd = 1)
y[i] ~ dnorm(x[i], sd = 1)
N_t_inf[i] ~ dpois(exp(lambda[1]))
N_t_T[i] ~ dbinom(prob=q_t,size=N_t_inf[i])
}
})
## build the model
stateSpaceModel <- nimbleModel(stateSpaceCode,
data = data,
constants = constants,
inits = inits,
dimensions=list(p_d = d),
check = FALSE)
bootstrapFilter <- buildBootstrapFilter(stateSpaceModel, nodes = 'x')
compiledList <- compileNimble(stateSpaceModel, bootstrapFilter)
compiledList$bootstrapFilter$run(10000)
library(nimble)
T_max <- 4
d<- 3
N_t_T = c(
1,2,3,4
)
## STATE SPACE MODEL STUFF
data <- list(
N_t_T = N_t_T
)
constants <- list(
t = T_max,
d = d
)
inits <- list(
alpha = rep(1,3)
)
## define the model
stateSpaceCode <- nimbleCode({
p_d[1:3] ~ ddirch(alpha[1:3])
q_t <- p_d[1]
x[1] ~ dnorm( 0, sd =1)
lambda[1] ~ dnorm( x[1], sd = 10)
N_t_inf[1] ~ dpois(exp(lambda[1]))
N_t_T[1] ~ dbinom(prob=q_t,size=N_t_inf[1])
for (i in 2:t) {
x[i] ~ dnorm(x[i - 1], sd = 1)
y[i] ~ dnorm(x[i], sd = 1)
N_t_inf[i] ~ dpois(exp(lambda[1]))
N_t_T[i] ~ dbinom(prob=q_t,size=N_t_inf[i])
}
})
## build the model
stateSpaceModel <- nimbleModel(stateSpaceCode,
data = data,
constants = constants,
inits = inits,
dimensions=list(p_d = d),
check = FALSE)
bootstrapFilter <- buildBootstrapFilter(stateSpaceModel, nodes = 'x')
compiledList <- compileNimble(stateSpaceModel, bootstrapFilter)
compiledList$bootstrapFilter$run(10000)
library(nimble)
T_max <- 4
d<- 3
N_t_T = c(
1,2,3,4
)
## STATE SPACE MODEL STUFF
data <- list(
N_t_T = N_t_T
)
constants <- list(
t = T_max,
d = d
)
inits <- list(
alpha = rep(1,3)
)
## define the model
stateSpaceCode <- nimbleCode({
p_d[] ~ ddirch(alpha[1:3])
q_t <- p_d[1]
x[1] ~ dnorm( 0, sd =1)
lambda[1] ~ dnorm( x[1], sd = 10)
N_t_inf[1] ~ dpois(exp(lambda[1]))
N_t_T[1] ~ dbinom(prob=q_t,size=N_t_inf[1])
for (i in 2:t) {
x[i] ~ dnorm(x[i - 1], sd = 1)
y[i] ~ dnorm(x[i], sd = 1)
N_t_inf[i] ~ dpois(exp(lambda[1]))
N_t_T[i] ~ dbinom(prob=q_t,size=N_t_inf[i])
}
})
## build the model
stateSpaceModel <- nimbleModel(stateSpaceCode,
data = data,
constants = constants,
inits = inits,
dimensions=list(p_d = d),
check = FALSE)
bootstrapFilter <- buildBootstrapFilter(stateSpaceModel, nodes = 'x')
compiledList <- compileNimble(stateSpaceModel, bootstrapFilter)
compiledList$bootstrapFilter$run(10000)
survFit <- read.table('survData.tsv', header = T)
setwd("~/Desktop")
list.files()
survFit <- read.table('survData.tsv', header = T)
head(survFit)
rawSurv <- survFit[,2:3]
head(rawSurv, 1:10)
head(rawSurv)
head(rawSurv, 10)
survProb = rawSurv$survival
month = rawSurv$month
library(icenReg)
args(ic_np)
args(ic_par)
weib_fit  <- ic_par(cbind(month_lower,
month_upper) ~ 0,
dist = "weibull",
weights = prob_in_interval)
month_lower = month[-length(month)]
month_upper = month[-1]
prob_in_interval = survProb[-length(survProb)] - survProb[-1]
weib_fit  <- ic_par(cbind(month_lower,
month_upper) ~ 0,
dist = "weibull",
weights = prob_in_interval)
plot(weib_fit)
weib_fit
args(plot.icenRegFit)
args(icenReg:::plot.icenReg_fit)
plot(weib_fit,cis = F)
plot(weib_fit,cis = F)
lines(month, survProb, type = 's',
col = 'blue')
summary(prob_in_interval)
weib_fit  <- ic_par(cbind(month_lower,
month_upper) ~ 0,
dist = "weibull",
weights = prob_in_interval * 100)
plot(weib_fit,cis = F)
lines(month, survProb, type = 's',
col = 'blue')
weib_fit  <- ic_par(cbind(month_lower,
month_upper) ~ 0,
dist = "weibull",
weights = prob_in_interval * 1000)
plot(weib_fit,cis = F)
lines(month, survProb, type = 's',
col = 'blue')
weib_fit  <- ic_par(cbind(month_lower,
month_upper) ~ 0,
dist = "weibull",
weights = prob_in_interval * 100000)
plot(weib_fit,cis = F)
lines(month, survProb, type = 's',
col = 'blue')
weib_fit
survProb
prob_in_interval
head(rawSurv, 1:10)
month = rawSurv$month
survProb = rawSurv$survival
month[nrow(rawSurv) + 1] = Inf
survProb[nrow(rawSurv) + 1] = 0
month_lower = month[-length(month)]
month_upper = month[-1]
prob_in_interval = survProb[-length(survProb)] - survProb[-1]
prob_in_interval
weib_fit  <- ic_par(cbind(month_lower,
month_upper) ~ 0,
dist = "weibull",
weights)
weib_fit  <- ic_par(cbind(month_lower,
month_upper) ~ 0,
dist = "weibull",
weights = prob_in_interval)
plot(weib_fit,cis = F)
prob_in_interval
plot(weib_fit,cis = F,
xlim = c(0, 60))
lines(month, survProb, type = 's',
col = 'blue')
weib_fit  <- ic_par(cbind(month_lower,
month_upper) ~ 0,
dist = "weibull",
weights = prob_in_interval * 100)
plot(weib_fit,cis = F,
xlim = c(0, 60))
lines(month, survProb, type = 's',
col = 'blue')
args(survCIs)
setwd("~/Desktop/icenReg_devel/Code/icenReg")
library(devtools)
install.packages('devtools')
library(devtools)
document()
args(survCIs)
document()
library(icenReg)
data(miceData)
head(miceData)
list.files()
library(devtools)
document()
document()
library(icenReg)
library(devtools)
document()
rm(list = ls())
library(icenReg)
# Fitting mice data set
data(miceData)
miceFit <- ic_par(cbind(l, u) ~ grp, data = miceData)
# Creating covariates we want plotted
newData <- data.frame(grp = c("ce", "ge"))
# Naming rows for legend
rownames(newData) <- c("Conventional", "Germ-Free")
plot(miceData, newdata = newData,
col = c('blue', 'orange'))
library(devtools)
library(devtools)
document()
library(icenReg)
# Fitting mice data set
data(miceData)
miceFit <- ic_par(cbind(l, u) ~ grp, data = miceData)
# Creating covariates we want plotted
newData <- data.frame(grp = c("ce", "ge"))
# Naming rows for legend
rownames(newData) <- c("Conventional", "Germ-Free")
plot(miceFit, newdata = newData,
col = c('blue', 'orange'))
library(icenReg)
# Fitting mice data set
data(miceData)
miceFit <- ic_par(cbind(l, u) ~ grp, data = miceData)
# Creating covariates we want plotted
newData <- data.frame(grp = c("ce", "ge"))
# Naming rows for legend
rownames(newData) <- c("Conventional", "Germ-Free")
plot(miceFit, newdata = newData,
col = c('blue', 'orange'))
library(icenReg)
# Fitting mice data set
data(miceData)
miceFit <- ic_par(cbind(l, u) ~ grp, data = miceData)
# Creating covariates we want plotted
newData <- data.frame(grp = c("ce", "ge"))
# Naming rows for legend
rownames(newData) <- c("Conventional", "Germ-Free")
plot(miceFit, newdata = newData,
col = c('blue', 'orange'))
plot.icenReg
plot.icenReg_fit
icenReg:::plot.icenReg_fit
document()
library(devtools)
document()
document()
library(icenReg)
args(icenReg:::plot.icenReg_fit)
