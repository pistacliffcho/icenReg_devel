
R version 3.2.0 (2015-04-16) -- "Full of Ingredients"
Copyright (C) 2015 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin13.4.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "icenReg"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('icenReg')
Loading required package: survival
Loading required package: foreach
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("diag_baseline")
> ### * diag_baseline
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: diag_baseline
> ### Title: Compare parametric baseline distributions with semi-parametric
> ###   baseline
> ### Aliases: diag_baseline
> 
> ### ** Examples
> 
> 	# Not run: requires data from the straweib library. 
> 	
> 	# library(straweib)
> 	# data(tooth24)
> 	# fit_po <- ic_sp(Surv(left, right, type = 'interval2') ~ dmf + sex,
> 	#                 data = tooth24, bs_samples = 0, model = 'po')
> 	#
> 	# diag_baseline(fit_po)
> 
> 	# Weibull model appears best fit
> 
> 
> 
> cleanEx()
> nameEx("diag_covar")
> ### * diag_covar
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: diag_covar
> ### Title: Evaluate covariate effect for regression model
> ### Aliases: diag_covar
> 
> ### ** Examples
> 
> 	# Not run: requires data from the straweib library. 
> 	
> 	# library(straweib)
> 	# data(tooth24)
> 	#
> 	# diag_covar(Surv(left, right, type = 'interval2') ~ sex + dmf, 
> 	#                 data = tooth24, model = 'po')
> 	# quartz()
> 	# diag_covar(Surv(left, right, type = 'interval2') ~ sex + dmf, 
> 	#                 data = tooth24, model = 'ph')
> 
> 	# For sex, both models fit pretty well
> 	# dmf looks a problematic; proportional odds looks a little better
> 	# proportional odds also leads to lower final likelihood
> 	
> 
> 
> 
> cleanEx()
> nameEx("essIncData")
> ### * essIncData
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: essIncData
> ### Title: Interval Censored Income Data from European Social Survey
> ### Aliases: essIncData
> 
> ### ** Examples
> 
> 	data(essIncData)
> 	
> 	lnormFit <- ic_par(Surv(inc_l, inc_u, type = 'interval2') ~ eduLevel * cntry, 	
+ 	                   data = essIncData,
+ 	                   model = 'po',
+ 	                   dist = 'loglogistic')
> 	
> 	summary(lnormFit)

Model: Proportional Odds
Baseline: loglogistic
Call = 
ic_par(formula = Surv(inc_l, inc_u, type = "interval2") ~ eduLevel * 
    cntry, data = essIncData, model = "po", dist = "loglogistic")

                               Estimate  Exp(Est) Std. Error  z-value         p
log_alpha                       7.75000 2322.0000    0.02028 382.1000 0.000e+00
log_beta                        1.04300    2.8360    0.01190  87.6300 0.000e+00
eduLevel[12,16)                 1.12300    3.0740    0.08921  12.5900 0.000e+00
eduLevel[16,Inf)                2.17100    8.7700    0.11870  18.2900 0.000e+00
cntryPoland                     2.69700   14.8400    0.09554  28.2300 0.000e+00
cntryRussia                     0.96120    2.6150    0.08485  11.3300 0.000e+00
cntrySlovakia                   1.12500    3.0800    0.11390   9.8790 0.000e+00
eduLevel[12,16):cntryPoland    -0.20260    0.8166    0.13960  -1.4510 1.467e-01
eduLevel[16,Inf):cntryPoland   -0.20600    0.8139    0.17060  -1.2080 2.272e-01
eduLevel[12,16):cntryRussia    -0.06104    0.9408    0.12290  -0.4968 6.193e-01
eduLevel[16,Inf):cntryRussia   -0.38800    0.6784    0.16740  -2.3180 2.043e-02
eduLevel[12,16):cntrySlovakia  -0.28680    0.7507    0.14740  -1.9450 5.176e-02
eduLevel[16,Inf):cntrySlovakia -0.81890    0.4409    0.18740  -4.3690 1.249e-05

final llk =  -14410.81 
Iterations =  108 
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("getFitEsts")
> ### * getFitEsts
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: getFitEsts
> ### Title: Get Estimates from icenReg Regression Model
> ### Aliases: getFitEsts
> 
> ### ** Examples
> 
> 	simdata <- simIC_weib(n = 500, b1 = .3, b2 = -.3,
+                          inspections = 6, inspectLength = 1)
> 	fit <- ic_par(Surv(l, u, type = 'interval2') ~ x1 + x2,
+                   data = simdata)
> 	new_data <- data.frame(x1 = c(1,2), x2 = c(-1,1))
> 	rownames(new_data) <- c('grp1', 'grp2')
> 	
> 	estQ <- getFitEsts(fit, new_data, p = c(.25, .5, .75))
> 	
> 	estP <- getFitEsts(fit, q = 400)
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("getSCurves")
> ### * getSCurves
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: getSCurves
> ### Title: Get Estimated Survival Curves from Semi-parametric Model for
> ###   Interval Censored Data
> ### Aliases: getSCurves
> 
> ### ** Examples
> 
> 	set.seed(1)
> 
> 	sim_data <- simIC_weib(n = 500, b1 = .3, b2 = -.3,
+ 	                      shape = 2, scale = 2,
+ 	                      inspections = 6, inspectLength = 1)
> 	fit <- ic_sp(Surv(l, u, type = 'interval2') ~ x1 + x2, data = sim_data, bs_samples = 0)	
> 
> 	new_data <- data.frame(x1 = c(0,1), x2 = c(1, 1) )
> 	#want to fit survival curves with above covariates
> 	rownames(new_data) <- c('group 1', 'group 2')
> 	#getSCurves will name the survival curves according to rownames
> 
> 	curveInfo <- getSCurves(fit, new_data)
> 	xs <- curveInfo$Tbull_ints
> 	#Extracting Turnbull intervals
> 	sCurves <- curveInfo$S_curves
> 	#Extracting estimated survival curves
> 	
> 	plot(xs[,1], sCurves[[1]], xlab = 'time', ylab = 'S(t)', 
+ 	     type = 's', ylim = c(0,1),
+ 	     xlim = range(as.numeric(xs), finite = TRUE))
> 	#plotting upper survival curve estimate
> 	lines(xs[,2], sCurves[[1]], type = 's')
> 	#plotting lower survival curve estimate
> 	
> 	lines(xs[,1], sCurves[[2]], col = 'blue', type = 's')
> 	lines(xs[,2], sCurves[[2]], col = 'blue', type = 's')
> 	#plotting upper and lower survival curves for group 2
> 	
> 	# Actually, all this plotting is a unnecessary: 
> 	# plot(fit, new_data) will bascially do this all
> 	# But this is more of a tutorial in case custom
> 	# plots were desired
> 
> 
> 
> cleanEx()
> nameEx("ic_par")
> ### * ic_par
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ic_par
> ### Title: Parametric Regression Models for Interval Censored Data
> ### Aliases: ic_par
> 
> ### ** Examples
> 
> 	data(miceData)
> 	
> 	logist_ph_fit <- ic_par(Surv(l, u, type = 'interval2') ~ grp, 
+ 	                        data = miceData, dist = 'loglogistic')
> 
> 	logist_po_fit <- ic_par(Surv(l, u, type = 'interval2') ~ grp, 
+ 	                        data = miceData, dist = 'loglogistic', model = 'po')
> 
> 	summary(logist_ph_fit)

Model: Cox PH
Baseline: loglogistic
Call = 
ic_par(formula = Surv(l, u, type = "interval2") ~ grp, data = miceData, 
    dist = "loglogistic")

          Estimate Exp(Est) Std. Error z-value       p
log_alpha   6.7760  876.500     0.1670  40.570 0.00000
log_beta    0.9077    2.479     0.3979   2.281 0.02254
grpge       0.8015    2.229     0.3236   2.477 0.01325

final llk =  -80.24882 
Iterations =  57 
> 	summary(logist_po_fit)

Model: Proportional Odds
Baseline: loglogistic
Call = 
ic_par(formula = Surv(l, u, type = "interval2") ~ grp, data = miceData, 
    model = "po", dist = "loglogistic")

          Estimate Exp(Est) Std. Error z-value        p
log_alpha    6.746 851.0000     0.1445  46.700 0.000000
log_beta     1.001   2.7200     0.3828   2.614 0.008947
grpge       -1.172   0.3097     0.4713  -2.487 0.012880

final llk =  -80.30575 
Iterations =  31 
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("ic_sp")
> ### * ic_sp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ic_sp
> ### Title: Semi-Parametric models for Interval Censored Data
> ### Aliases: ic_sp vcov.icenReg_fit summary.icenReg_fit plot.icenReg_fit
> 
> ### ** Examples
> 
> 	set.seed(1)
> 
> 	sim_data <- simIC_weib(n = 500, inspections = 5, inspectLength = 1)
> 	ph_fit <- ic_sp(Surv(l, u, type = 'interval2') ~ x1 + x2, data = sim_data)	
> 	# Default fits a Cox-PH model
> 	
> 	summary(ph_fit)		

Model: Cox PH
Baseline: semi-parametric
Call = 
ic_sp(formula = Surv(l, u, type = "interval2") ~ x1 + x2, data = sim_data)
   Estimate Exp(Est)
x1   0.5458   1.7260
x2  -0.5146   0.5977
final llk =  -643.8913 
Iterations =  22 
Standard Errors not available. To get standard errors, rerun ic_ph with "bs_samples" > 0 (suggested at least 1000)> 	# Regression estimates close to true 0.5 and -0.5 values
> 
> 
> 	new_data <- data.frame(x1 = c(0,1), x2 = c(1, 1) )
> 	rownames(new_data) <- c('group 1', 'group 2')
> 	plot(ph_fit, new_data)
> 	# plotting the estimated survival curves
> 
> 	po_fit <- ic_sp(Surv(l, u, type = 'interval2') ~ x1 + x2, data = sim_data,
+ 	                model = 'po')
> 	# fits a proportional odds model
> 	
> 	summary(po_fit)

Model: Proportional Odds
Baseline: semi-parametric
Call = 
ic_sp(formula = Surv(l, u, type = "interval2") ~ x1 + x2, data = sim_data, 
    model = "po")
   Estimate Exp(Est)
x1  -0.6966   0.4983
x2   0.7135   2.0410
final llk =  -664.025 
Iterations =  12 
Standard Errors not available. To get standard errors, rerun ic_ph with "bs_samples" > 0 (suggested at least 1000)> 	
> 	# Not run: how to set up multiple cores
> 	# library(doParallel)
> 	# myCluster <- makeCluster(2, type = 'FORK') 
> 	# registerDoParallel(myCluster)
> 	# fit <- ic_sp(Surv(l, u, type = 'interval2') ~ x1 + x2,
> 	#              data = sim_data, useMCores = TRUE)	
> 
> 
> 
> cleanEx()
> nameEx("miceData")
> ### * miceData
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: miceData
> ### Title: Lung Tumor Interval Censored Data from Hoel and Walburg 1972
> ### Aliases: miceData
> 
> ### ** Examples
> 
> 	data(miceData)
> 	
> 	coxph_fit <- ic_sp(Surv(l, u, type = 'interval2') ~ grp, 
+ 	                   bs_samples = 50,	
+ 	                   data = miceData)
warning: likelihood decreased! difference = -0.000050
warning: likelihood decreased! difference = -0.000039
warning: likelihood decreased! difference = -0.000065
warning: likelihood decreased! difference = -0.000055
warning: likelihood decreased! difference = -0.000048
warning: likelihood decreased! difference = -0.000051
> 	
> 	#In practice, more bootstrap samples should be used for inference
> 	#Keeping it quick for CRAN testing purposes 
> 	
> 	summary(coxph_fit)

Model: Cox PH
Baseline: semi-parametric
Call = 
ic_sp(formula = Surv(l, u, type = "interval2") ~ grp, data = miceData, 
    bs_samples = 50)

      Estimate Exp(Est) Std. Error z-value      p
grpge   0.6277    1.873     0.4272    1.47 0.1417

final llk =  -76.53436 
Iterations =  49 
Bootstrap samples =  50 
CAUTION: recommend more bootstrap samples for inference!
Iterations =  49 
> 
> 
> 
> cleanEx()
> nameEx("simIC_weib")
> ### * simIC_weib
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: simIC_weib
> ### Title: Simulates interval censored data from regression model with a
> ###   Weibull baseline
> ### Aliases: simIC_weib
> 
> ### ** Examples
> 
> 	set.seed(1)
> 	sim_data <- simIC_weib(n = 2000, b1 = .3, b2 = -.3, model = 'ph', 
+ 	                       shape = 2, scale = 2, inspections = 6, inspectLength = 1)
> 	#simulates data from a cox-ph with beta weibull distribution.
> 	
> 	diag_covar(Surv(l, u, type = 'interval2') ~ x1 + x2, data = sim_data, model = 'po')
> 	diag_covar(Surv(l, u, type = 'interval2') ~ x1 + x2, data = sim_data, model = 'ph')
> 	#'ph' fit looks better than 'po'; the difference between the transformed survival
> 	#function looks more constant
> 
> 
> 
> ### * <FOOTER>
> ###
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  7.711 0.016 7.729 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
