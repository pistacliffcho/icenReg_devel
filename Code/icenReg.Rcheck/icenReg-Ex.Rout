
R version 3.2.2 (2015-08-14) -- "Fire Safety"
Copyright (C) 2015 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin13.4.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "icenReg"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> base::assign(".ExTimings", "icenReg-Ex.timings", pos = 'CheckExEnv')
> base::cat("name\tuser\tsystem\telapsed\n", file=base::get(".ExTimings", pos = 'CheckExEnv'))
> base::assign(".format_ptime",
+ function(x) {
+   if(!is.na(x[4L])) x[1L] <- x[1L] + x[4L]
+   if(!is.na(x[5L])) x[2L] <- x[2L] + x[5L]
+   options(OutDec = '.')
+   format(x[1L:3L], digits = 7L)
+ },
+ pos = 'CheckExEnv')
> 
> ### * </HEADER>
> library('icenReg')
Loading required package: survival
Loading required package: MLEcens
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("ICNPMLE")
> ### * ICNPMLE
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ICNPMLE
> ### Title: Computes the NPMLE for Univariate or Bivariate Interval Censored
> ###   Data
> ### Aliases: ICNPMLE IC_NPMLE
> 
> ### ** Examples
> 
> simData <- simBVCen(500)
> 
> fit <- ICNPMLE(simData)
> 
> fit
Bivariate Interval Censored Optimization Results
Final log likelihood =  -799.561 
Numeric Error =  7.646639e-11 
Total iterations =  222 
Outer iterations =  5 
Number of maximal intersections =  4046 
Number of maximal intersections w/ positive mass =  58 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ICNPMLE", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("diag_baseline")
> ### * diag_baseline
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: diag_baseline
> ### Title: Compare parametric baseline distributions with semi-parametric
> ###   baseline
> ### Aliases: diag_baseline
> 
> ### ** Examples
> 
> 	 data(essIncData_small)
> 	 useData <- essIncData_small
> 	 
> 	 #Note to user: suggest replacing useData with essIncData
> 	 #instead of essIncData_small. Using small dataset to quickly 
> 	 #pass CRAN tests
> 	 
> 	 fit_po <- ic_sp(Surv(inc_l, inc_u, type = 'interval2') ~ eduLevel * cntry,
+ 	                 data = useData, bs_samples = 0, model = 'po')
> 	
> 	 diag_baseline(fit_po)
> 
> 	 #Weibull model appears best fit
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("diag_baseline", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("diag_covar")
> ### * diag_covar
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: diag_covar
> ### Title: Evaluate covariate effect for regression model
> ### Aliases: diag_covar
> 
> ### ** Examples
> 
> 	 data(essIncData_small)
> 	 useData <- essIncData_small
> 	 
> 	 #Note to user: suggest replacing useData with essIncData
> 	 #instead of essIncData_small. Using small dataset to quickly 
> 	 #pass CRAN tests
> 	 par(mfrow = c(1,2))
> 	 	 
> 	 diag_covar(Surv(inc_l, inc_u, type = 'interval2') ~ eduLevel * cntry, 
+ 		         data = useData, model = 'po')
> 		
> 	 diag_covar(Surv(inc_l, inc_u, type = 'interval2') ~ eduLevel * cntry, 
+ 		         data = useData, model = 'ph')
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("diag_covar", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("essIncData")
> ### * essIncData
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: essIncData
> ### Title: Interval Censored Income Data from European Social Survey
> ### Aliases: essIncData
> 
> ### ** Examples
> 
> #	Not run
> 
> #	data(essIncData)
> #	
> #	lnormFit <- ic_par(Surv(inc_l, inc_u, type = 'interval2') ~ eduLevel * cntry, 	
> #	                   data = essIncData,
> #	                   model = 'po',
> #	                   dist = 'loglogistic')
> #	
> #	summary(lnormFit)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("essIncData", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("essIncData_small")
> ### * essIncData_small
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: essIncData_small
> ### Title: Interval Censored Income Data from European Social Survey
> ### Aliases: essIncData_small
> 
> ### ** Examples
> 
> 	data(essIncData_small)
> 	
> 	lnormFit <- ic_par(Surv(inc_l, inc_u, type = 'interval2') ~ eduLevel * cntry, 	
+ 	                   data = essIncData_small,
+ 	                   model = 'po',
+ 	                   dist = 'loglogistic')
> 	
> 	summary(lnormFit)

Model:  Proportional Odds 
Baseline:  loglogistic 
Call: ic_par(formula = Surv(inc_l, inc_u, type = "interval2") ~ eduLevel * 
    cntry, data = essIncData_small, model = "po", dist = "loglogistic")

                               Estimate  Exp(Est) Std.Error   z-value         p
log_alpha                       8.35200 4239.0000   0.02784 300.00000 0.000e+00
log_beta                        1.05500    2.8730   0.04374  24.13000 0.000e+00
eduLevel[12,16)                 1.23600    3.4430   0.34340   3.60000 3.181e-04
eduLevel[16,Inf)                2.75300   15.6900   0.47000   5.85700 4.703e-09
cntryPoland                     2.24200    9.4090   0.35020   6.40100 1.548e-10
cntryRussia                     1.08300    2.9540   0.31990   3.38600 7.094e-04
cntrySlovakia                   1.15000    3.1580   0.37580   3.06000 2.216e-03
eduLevel[12,16):cntryPoland     0.22100    1.2470   0.53830   0.41060 6.814e-01
eduLevel[16,Inf):cntryPoland   -0.01386    0.9862   0.64010  -0.02165 9.827e-01
eduLevel[12,16):cntryRussia    -0.38500    0.6805   0.46980  -0.81950 4.125e-01
eduLevel[16,Inf):cntryRussia   -1.04800    0.3507   0.60840  -1.72200 8.502e-02
eduLevel[12,16):cntrySlovakia  -0.59840    0.5497   0.51170  -1.16900 2.422e-01
eduLevel[16,Inf):cntrySlovakia -1.15400    0.3155   0.69050  -1.67000 9.483e-02

final llk =  -1053.966 
Iterations =  18 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("essIncData_small", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("getFitEsts")
> ### * getFitEsts
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: getFitEsts
> ### Title: Get Estimates from icenReg Regression Model
> ### Aliases: getFitEsts
> 
> ### ** Examples
> 
> 	simdata <- simIC_weib(n = 500, b1 = .3, b2 = -.3,
+                          inspections = 6, inspectLength = 1)
> 	fit <- ic_par(Surv(l, u, type = 'interval2') ~ x1 + x2,
+                   data = simdata)
> 	new_data <- data.frame(x1 = c(1,2), x2 = c(-1,1))
> 	rownames(new_data) <- c('grp1', 'grp2')
> 	
> 	estQ <- getFitEsts(fit, new_data, p = c(.25, .5, .75))
> 	
> 	estP <- getFitEsts(fit, q = 400)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("getFitEsts", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("getSCurves")
> ### * getSCurves
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: getSCurves
> ### Title: Get Estimated Survival Curves from Semi-parametric Model for
> ###   Interval Censored Data
> ### Aliases: getSCurves
> 
> ### ** Examples
> 
> 	set.seed(1)
> 
> 	sim_data <- simIC_weib(n = 500, b1 = .3, b2 = -.3,
+ 	                      shape = 2, scale = 2,
+ 	                      inspections = 6, inspectLength = 1)
> 	fit <- ic_sp(Surv(l, u, type = 'interval2') ~ x1 + x2, data = sim_data, bs_samples = 0)	
> 
> 	new_data <- data.frame(x1 = c(0,1), x2 = c(1, 1) )
> 	#want to fit survival curves with above covariates
> 	rownames(new_data) <- c('group 1', 'group 2')
> 	#getSCurves will name the survival curves according to rownames
> 
> 	curveInfo <- getSCurves(fit, new_data)
> 	xs <- curveInfo$Tbull_ints
> 	#Extracting Turnbull intervals
> 	sCurves <- curveInfo$S_curves
> 	#Extracting estimated survival curves
> 	
> 	plot(xs[,1], sCurves[[1]], xlab = 'time', ylab = 'S(t)', 
+ 	     type = 's', ylim = c(0,1),
+ 	     xlim = range(as.numeric(xs), finite = TRUE))
> 	#plotting upper survival curve estimate
> 	lines(xs[,2], sCurves[[1]], type = 's')
> 	#plotting lower survival curve estimate
> 	
> 	lines(xs[,1], sCurves[[2]], col = 'blue', type = 's')
> 	lines(xs[,2], sCurves[[2]], col = 'blue', type = 's')
> 	#plotting upper and lower survival curves for group 2
> 	
> 	# Actually, all this plotting is a unnecessary: 
> 	# plot(fit, new_data) will bascially do this all
> 	# But this is more of a tutorial in case custom
> 	# plots were desired
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("getSCurves", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ic_par")
> ### * ic_par
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ic_par
> ### Title: Parametric Regression Models for Interval Censored Data
> ### Aliases: ic_par
> 
> ### ** Examples
> 
> 	data(miceData)
> 	
> 	logist_ph_fit <- ic_par(Surv(l, u, type = 'interval2') ~ grp, 
+ 	                        data = miceData, dist = 'loglogistic')
> 
> 	logist_po_fit <- ic_par(Surv(l, u, type = 'interval2') ~ grp, 
+ 	                        data = miceData, dist = 'loglogistic', model = 'po')
> 
> 	summary(logist_ph_fit)

Model:  Cox PH 
Baseline:  loglogistic 
Call: ic_par(formula = Surv(l, u, type = "interval2") ~ grp, data = miceData, 
    dist = "loglogistic")

          Estimate Exp(Est) Std.Error z-value       p
log_alpha   6.6310  758.500   0.08673  76.460 0.00000
log_beta    0.9596    2.611   0.38670   2.482 0.01308
grpge       0.8098    2.247   0.32280   2.509 0.01211

final llk =  -80.23726 
Iterations =  30 
> 	summary(logist_po_fit)

Model:  Proportional Odds 
Baseline:  loglogistic 
Call: ic_par(formula = Surv(l, u, type = "interval2") ~ grp, data = miceData, 
    model = "po", dist = "loglogistic")

          Estimate Exp(Est) Std.Error z-value        p
log_alpha    6.603 737.2000   0.07747  85.240 0.000000
log_beta     1.001   2.7200   0.38280   2.614 0.008943
grpge       -1.172   0.3097   0.47130  -2.487 0.012880

final llk =  -80.30575 
Iterations =  20 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ic_par", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("ic_sp")
> ### * ic_sp
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ic_sp
> ### Title: Semi-Parametric models for Interval Censored Data
> ### Aliases: ic_sp vcov.icenReg_fit summary.icenReg_fit plot.icenReg_fit
> 
> ### ** Examples
> 
> 	set.seed(1)
> 
> 	sim_data <- simIC_weib(n = 500, inspections = 5, inspectLength = 1)
> 	ph_fit <- ic_sp(Surv(l, u, type = 'interval2') ~ x1 + x2, data = sim_data)	
> 	# Default fits a Cox-PH model
> 	
> 	summary(ph_fit)		

Model:  Cox PH 
Baseline:  semi-parametric 
Call: ic_sp(formula = Surv(l, u, type = "interval2") ~ x1 + x2, data = sim_data)

   Estimate Exp(Est)
x1   0.5458   1.7260
x2  -0.5146   0.5977

final llk =  -643.8913 
Iterations =  23 
Bootstrap Samples =  0 
WARNING: only  0  bootstrap samples used for standard errors. Suggest using more bootstrap samples for inference
> 	# Regression estimates close to true 0.5 and -0.5 values
> 
> 
> 	new_data <- data.frame(x1 = c(0,1), x2 = c(1, 1) )
> 	rownames(new_data) <- c('group 1', 'group 2')
> 	plot(ph_fit, new_data)
> 	# plotting the estimated survival curves
> 
> 	po_fit <- ic_sp(Surv(l, u, type = 'interval2') ~ x1 + x2, data = sim_data,
+ 	                model = 'po')
> 	# fits a proportional odds model
> 	
> 	summary(po_fit)

Model:  Proportional Odds 
Baseline:  semi-parametric 
Call: ic_sp(formula = Surv(l, u, type = "interval2") ~ x1 + x2, data = sim_data, 
    model = "po")

   Estimate Exp(Est)
x1  -0.6966   0.4983
x2   0.7135   2.0410

final llk =  -664.025 
Iterations =  9 
Bootstrap Samples =  0 
WARNING: only  0  bootstrap samples used for standard errors. Suggest using more bootstrap samples for inference
> 	
> 	# Not run: how to set up multiple cores
> 	# library(doParallel)
> 	# myCluster <- makeCluster(2, type = 'FORK') 
> 	# registerDoParallel(myCluster)
> 	# fit <- ic_sp(Surv(l, u, type = 'interval2') ~ x1 + x2,
> 	#              data = sim_data, useMCores = TRUE)	
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ic_sp", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("miceData")
> ### * miceData
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: miceData
> ### Title: Lung Tumor Interval Censored Data from Hoel and Walburg 1972
> ### Aliases: miceData
> 
> ### ** Examples
> 
> 	data(miceData)
> 	
> 	coxph_fit <- ic_sp(Surv(l, u, type = 'interval2') ~ grp, 
+ 	                   bs_samples = 50,	
+ 	                   data = miceData)
> 	
> 	#In practice, more bootstrap samples should be used for inference
> 	#Keeping it quick for CRAN testing purposes 
> 	
> 	summary(coxph_fit)

Model:  Cox PH 
Baseline:  semi-parametric 
Call: ic_sp(formula = Surv(l, u, type = "interval2") ~ grp, data = miceData, 
    bs_samples = 50)

      Estimate Exp(Est) Std.Error z-value      p
grpge   0.6277    1.873     0.497   1.263 0.2066

final llk =  -76.53436 
Iterations =  28 
Bootstrap Samples =  50 
WARNING: only  50  bootstrap samples used for standard errors. Suggest using more bootstrap samples for inference
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("miceData", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("optCliq")
> ### * optCliq
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: optCliq
> ### Title: Computes the MLE for a Binary Mixture Model.
> ### Aliases: optCliq cliqOptInfo
> 
> ### ** Examples
> 
> testData <- simBVCen()
> #simulate bivariate interval censored data
> 
> cliqMat <- MLEcens::reduc(testData, cm = TRUE)$cm
> #computes the cliqMat associated with data
> 
> cliqFit <- optCliq(cliqMat)
> #optimizes the component weights for clique matrix
> 
> cliqFit 
Clique Optimizer Object
Final log likelihood =  -1746.673 
Numeric Error =  6.782241e-11 
Total iterations =  411 
Outer iterations =  5 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("optCliq", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("simBVCen")
> ### * simBVCen
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: simBVCen
> ### Title: Simulates Bivariate Interval Censored Data
> ### Aliases: simBVCen
> 
> ### ** Examples
> 
>   testData <- simBVCen()
>   #simulate bivariate interval censored data
>   
>  bvcenFit <- ICNPMLE(testData)
>  
>  bvcenFit
Bivariate Interval Censored Optimization Results
Final log likelihood =  -1746.673 
Numeric Error =  6.782241e-11 
Total iterations =  411 
Outer iterations =  5 
Number of maximal intersections =  17800 
Number of maximal intersections w/ positive mass =  90 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("simBVCen", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("simIC_weib")
> ### * simIC_weib
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: simIC_weib
> ### Title: Simulates interval censored data from regression model with a
> ###   Weibull baseline
> ### Aliases: simIC_weib
> 
> ### ** Examples
> 
> 	set.seed(1)
> 	sim_data <- simIC_weib(n = 500, b1 = .3, b2 = -.3, model = 'ph', 
+ 	                       shape = 2, scale = 2, inspections = 6, inspectLength = 1)
> 	#simulates data from a cox-ph with beta weibull distribution.
> 	
> 	diag_covar(Surv(l, u, type = 'interval2') ~ x1 + x2, data = sim_data, model = 'po')
> 	diag_covar(Surv(l, u, type = 'interval2') ~ x1 + x2, data = sim_data, model = 'ph')
> 	#'ph' fit looks better than 'po'; the difference between the transformed survival
> 	#function looks more constant
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("simIC_weib", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> ### * <FOOTER>
> ###
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  3.972 0.091 4.068 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
